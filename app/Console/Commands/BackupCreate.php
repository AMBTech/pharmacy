<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class BackupCreate extends Command
{
    protected $signature = 'backup:create';
    protected $description = 'Create a database backup';

    public function handle()
    {
        $this->info('ðŸš€ Starting database backup...');

        // Get config
        $config = config('database.connections.mysql');

        // Check if we can connect to MySQL
        try {
            DB::connection()->getPdo();
            $this->info('âœ“ Database connection verified');
        } catch (\Exception $e) {
            $this->error('âœ— Database connection failed: ' . $e->getMessage());
            return 1;
        }

        // Create backup directory
        $backupDir = storage_path('app/backups');
        if (!is_dir($backupDir)) {
            mkdir($backupDir, 0755, true);
            $this->info('âœ“ Created backup directory');
        }

        $timestamp = now()->format('Y-m-d_H-i-s');
        $filename = "backup_{$timestamp}.sql";
        $filepath = "{$backupDir}/{$filename}";
        $compressedPath = "{$filepath}.gz";

        // Method 1: Try mysqldump with different approaches
        $success = $this->tryMysqldump($config, $filepath);

        if (!$success) {
            // Method 2: Fallback to Laravel-based backup
            $this->warn('mysqldump failed, trying Laravel method...');
            $success = $this->laravelBackup($config, $filepath);
        }

        if (!$success) {
            $this->error('âŒ All backup methods failed!');
            return 1;
        }

        // Compress the backup
        $this->compressFile($filepath, $compressedPath);

        // Verify the backup
        if ($this->verifyBackup($compressedPath)) {
            $this->info("âœ… Backup created successfully: " . basename($compressedPath));
            $this->info("ðŸ“ Location: " . $compressedPath);
            $this->info("ðŸ“Š Size: " . $this->formatBytes(filesize($compressedPath)));

            // Clean old backups (keep last 30)
            $this->cleanOldBackups($backupDir);

            return 0;
        } else {
            $this->error('âŒ Backup verification failed!');
            return 1;
        }
    }

    private function tryMysqldump($config, $outputPath)
    {
        $this->info('Trying mysqldump...');

        // Try different command formats
        $commands = [
            // Standard format
            sprintf(
                'mysqldump --host=%s --port=%s --user=%s --password=%s --routines --triggers --events --single-transaction --quick %s > %s 2>&1',
                escapeshellarg($config['host']),
                escapeshellarg($config['port']),
                escapeshellarg($config['username']),
                escapeshellarg($config['password']),
                escapeshellarg($config['database']),
                escapeshellarg($outputPath)
            ),

            // Without port
            sprintf(
                'mysqldump --host=%s --user=%s --password=%s %s > %s 2>&1',
                escapeshellarg($config['host']),
                escapeshellarg($config['username']),
                escapeshellarg($config['password']),
                escapeshellarg($config['database']),
                escapeshellarg($outputPath)
            ),

            // With full path (common locations)
            sprintf(
                '/usr/bin/mysqldump --host=%s --user=%s --password=%s %s > %s 2>&1',
                escapeshellarg($config['host']),
                escapeshellarg($config['username']),
                escapeshellarg($config['password']),
                escapeshellarg($config['database']),
                escapeshellarg($outputPath)
            ),
        ];

        foreach ($commands as $command) {
            // Hide password in log
            $safeCommand = str_replace($config['password'], '***', $command);
            $this->info("Trying: {$safeCommand}");

            exec($command, $output, $returnCode);

            if ($returnCode === 0 && filesize($outputPath) > 100) {
                $this->info('âœ“ mysqldump succeeded');
                return true;
            }

            // Clean failed attempt
            if (file_exists($outputPath)) {
                unlink($outputPath);
            }
        }

        return false;
    }

    private function laravelBackup($config, $outputPath)
    {
        $this->info('Creating backup using Laravel...');

        try {
            $sql = "-- MySQL dump generated by Laravel\n";
            $sql .= "-- Host: {$config['host']}\n";
            $sql .= "-- Database: {$config['database']}\n";
            $sql .= "-- Generation Time: " . now() . "\n\n";
            $sql .= "SET FOREIGN_KEY_CHECKS=0;\n\n";

            // Get all tables
            $tables = DB::select('SHOW TABLES');
            $dbName = $config['database'];
            $tableKey = "Tables_in_{$dbName}";

            foreach ($tables as $tableObj) {
                $tableName = $tableObj->$tableKey;
                $this->info("  Backing up table: {$tableName}");

                // Get create table statement
                $createResult = DB::selectOne("SHOW CREATE TABLE `{$tableName}`");
                $createStatement = $createResult->{'Create Table'};

                $sql .= "--\n-- Table structure for `{$tableName}`\n--\n";
                $sql .= "DROP TABLE IF EXISTS `{$tableName}`;\n";
                $sql .= "{$createStatement};\n\n";

                // Get table data
                $rows = DB::table($tableName)->get();
                if ($rows->count() > 0) {
                    $sql .= "--\n-- Data for `{$tableName}`\n--\n";

                    // Get column names
                    $firstRow = (array)$rows->first();
                    $columns = array_keys($firstRow);
                    $columnsStr = '`' . implode('`,`', $columns) . '`';

                    $values = [];
                    foreach ($rows as $row) {
                        $rowValues = [];
                        foreach ((array)$row as $value) {
                            if ($value === null) {
                                $rowValues[] = 'NULL';
                            } else {
                                $rowValues[] = "'" . addslashes($value) . "'";
                            }
                        }
                        $values[] = '(' . implode(',', $rowValues) . ')';
                    }

                    $sql .= "INSERT INTO `{$tableName}` ({$columnsStr}) VALUES \n";
                    $sql .= implode(",\n", $values) . ";\n\n";
                }
            }

            $sql .= "SET FOREIGN_KEY_CHECKS=1;\n";

            file_put_contents($outputPath, $sql);

            return filesize($outputPath) > 100;

        } catch (\Exception $e) {
            $this->error("Laravel backup failed: " . $e->getMessage());
            return false;
        }
    }

    private function compressFile($source, $destination)
    {
        $this->info('Compressing backup...');

        $mode = 'wb9';
        $sourceFile = fopen($source, 'rb');
        $destFile = gzopen($destination, $mode);

        while (!feof($sourceFile)) {
            gzwrite($destFile, fread($sourceFile, 4096));
        }

        fclose($sourceFile);
        gzclose($destFile);

        // Remove uncompressed file
        unlink($source);
    }

    private function verifyBackup($filepath)
    {
        if (!file_exists($filepath)) {
            return false;
        }

        $size = filesize($filepath);
        if ($size < 100) {
            $this->error("Backup file too small: {$size} bytes");
            return false;
        }

        // Try to read first few bytes to check if it's valid gzip
        $handle = gzopen($filepath, 'r');
        if ($handle) {
            $firstBytes = gzread($handle, 100);
            gzclose($handle);

            if (strpos($firstBytes, 'MySQL dump') !== false ||
                strpos($firstBytes, 'CREATE TABLE') !== false) {
                return true;
            }
        }

        return true; // Assume valid if we got this far
    }

    private function cleanOldBackups($directory)
    {
        $this->info('Cleaning old backups...');

        $files = glob("{$directory}/backup_*.sql.gz");
        $keepCount = 30; // Keep last 30 backups

        if (count($files) > $keepCount) {
            // Sort by modification time
            usort($files, function($a, $b) {
                return filemtime($b) - filemtime($a);
            });

            $toDelete = array_slice($files, $keepCount);

            foreach ($toDelete as $file) {
                unlink($file);
                $this->info("Deleted: " . basename($file));
            }

            $this->info("Kept {$keepCount} most recent backups");
        }
    }

    private function formatBytes($bytes)
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);

        return round($bytes, 2) . ' ' . $units[$pow];
    }
}
